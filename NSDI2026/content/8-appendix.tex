\appendix \label{apdx}

In a nutshell, Octopus uses the SPF algorithm in the RDM to find possible routes. With SPF, each node will generate an RIB, where each destination is associated with multiple entries. The number of entries equals the number of neighbors with a smaller ''distance'' to the destination (to avoid loop). 

Each entry in the RIB includes the interface of the current node to use, the estimated cost if using this interface, and the next-hop's interface along the path to the destination. For Octopus, the estimated cost in the RIB is determined as the minimum path delay (assuming zero queueing delay along the path) from the current node to the destination via the next-hop node associated with each entry. Subsequently, the traffic information within the one-hop neighborhood is utilized to calculate the reward of each routing decision, effectively limiting communication overheads.

Formally, consider a graph $\mathcal{G} = (V, E)$. For each node $v \in V$, denote by $N_v$ the set of its neighbor nodes. Denote by $D_v = V \setminus v$ the set of all possible destinations for packets to be forwarded by $v$. 

After running SPF, for each destination $d \in D_v$,  $v$ finds a set of available paths, associated with its interface set $v_d$. Each path (interface) $i \in v_d$ is associated with the cost $c_i$ (i.e., the minimum path delay if choosing interface $i$ to $d$ without queueing delay) and the next-hop interface $i^\prime$. Here, $c_i$ is considered static unless there is any topology changes.

The fast-changing part in the network is the queueing delays. The traffic information exchange between neighbor nodes can occur frequently, as the number of bits needed for traffic information between neighbors is quite negligible.
Therefore, Octopus can use the queuing delay of both current and next-hop interfaces for path selection. 

With a slight abuse of notation, we denote by $d_i$ the queueing delay for a packet going through interface $i$. Then, we define the loss of selecting $i \in v_d$ for forwarding one packet as 
$$l_i:= 1-e^{ -(c_i + d_i+ d_{i^\prime})},$$
where $d_{i^\prime}$ is the queuing delay for interface $i^\prime$ on the next-hop nodes. Note that $d_i$ can be observed by the current node, and $d_{i^\prime}$ requires the feedback from the next-hop neighbor. $l_i$ increases when delay increases.  

\begin{algorithm}
\caption{Octopus Routing Selection on Node $v \in V$}\label{alg:oct}
\begin{algorithmic}[1]
\Require $v_d, \forall d \in D_v$ after running SPF
% \Ensure $y = x^n$
\For{$d \in D_v$} \Comment{Initialization for all destinations}
\State $N_d = 0$
\For{$i \in v_d$}
\State $L_i \gets 1 - e^{-c_i}$
\EndFor
\EndFor
\While{Packet}
\State $d \gets$ Packet.destination
\State $N_d \gets N_d + 1$
\State $\eta_d = \sqrt{\frac{|v_d|\ln |v_d|}{N_d}}$
\State $p_i \gets \frac{e^{-\eta_d L_i}}{\sum\limits_{j \in v_d}e^{-\eta_d L_j }}, \forall i \in v_d$
\State Forward Packet to interface $i$ according to $p_i$
\State Observe the queuing delay $d_{i^\prime}$ on the next-hop interface $i^\prime$
\State Update $L_i \gets L_i + \frac{l_i}{p_i}$
\EndWhile
\end{algorithmic}
\end{algorithm}

With the above notations, Octopus is given in Algorithm~\ref{alg:oct}.
For each destination $d \in D_v$,  a counter $N_d$ is used to count how many packets have been forwarded to $d$, and for each route entry $i$, we maintain a variable $L_i$, which keeps track of the cumulative loss for forwarding packets to $d$ via $i$. $N_d$ and $L_i$ are initialized in the for-loop of lines $1$ to $5$ in Algorithm~\ref{alg:oct}. 

Path selection in Octopus fundamentally operates with two processes: observing queue reports from neighboring routers and adjusting its forwarding decisions accordingly. Neighbors sent queue length reports through all active links. 

The reception of a one-hop queuing delay report can be used to obtain $d_{i^\prime}$ to update $l_i$ and $L_i$.  $L_i$ and the learning rate $\eta_d$ (determined by $N_d$), in line $10$, is used to calculate the probability of selecting $i$, $p_i$ in line $11$ of Algorithm~\ref{alg:oct}. Finally, the forwarding decision is sampled from the distribution $p_i$. 